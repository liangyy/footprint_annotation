# This module implements the strategy2 for footprint annotation task.
# Recall that footprint annotation takes a list of variants and predicts whether
# it locates in footprint regions and whether it alters binding affinity

# In strategy2, we takes an experiment and learns a CENTIPEDE model for each
# motif-experiment pair. Motifs are taken from recalibrated one in the paper
# Which genetic variants in DNase-seq footprints are more likely to alter binding?

rule align_fastq2sai:
    input:
        fastq = lambda wildcards: config['experiments'][wildcards.sample]['fastq']
    output:
        sai = temp('temp/align/{sample}.sai')
    params:
        ref = config['genome_assembly']['fasta'],
    threads: config['ncpus']
    shell:
        'bwa aln -Y -l 32 -n 0.04 -k 2 -t {threads} {params.ref} {input.fastq} > {output.sai}'

rule align_sai2sam:
    input:
        'temp/align/{sample}.sai',
        lambda wildcards: config['experiments'][wildcards.sample]['fastq']
    output:
        temp('temp/align/{sample}.sam')
    params:
        ref = config['genome_assembly']['fasta']
    shell:
        'bwa samse -n 10 {params.ref} {input[0]} {input[1]} > {output[0]}'

rule align_sam2bam:
    input:
        'temp/align/{sample}.sam'
    output:
        temp('temp/align/{sample}.bam')
    shell:
        'samtools view -Shb {input[0]} > {output[0]}'

rule align_bam_sort:
    input:
        'temp/align/{sample}.bam'
    output:
        'data/align/{sample}.sorted.bam'
    threads: config['ncpus']
    shell:
        'samtools sort -@ {threads} -m 4G -o {output[0]} {input[0]}'

rule align_bam_index:
    input:
        'data/align/{sample}.sorted.bam'
    output:
        'data/align/{sample}.sorted.bai'
    shell:
        'samtools index {input[0]}'

rule pile_fastq2mpile:
    input:
        'data/align/{sample}.sorted.bam',
        'data/align/{sample}.sorted.bai',
        config['genome_assembly']['fasta']
    output:
        'data/pile/{sample}.mpile.gz'
    shell:
        '''samtools view -b -q 10 {input[0]} | \
        samtools mpileup -f {input[2]} - > {output[0]}'''

rule scan_prepare_get_fasta:
    input:
        region = lambda wildcards: config['experiments'][wildcards.sample]['bed']
    params:
        genome_fa = lambda wilcards: config['genome_assembly']['fasta'],
        genome_size = lambda wilcards: config['genome_assembly']['size'],
        extend_bed = lambda wildcards: config['active_motifs']['extend_bed']
    output:
        'data/scan/{sample}.extend_{size}.fasta.gz'
    shell:
        '''
        # get sequences
        bedtools getfasta -fi {params.genome_fa} \
        -bed <(bedtools slop -i <(zcat {input.region}) -g {params.genome_size} -b {params.extend_bed}) \
        -fo {output[0]}.temp
        # compress
        cat {output[0]}.temp | gzip > {output[0]}
        rm {output[0]}.temp
        '''

import glob
import ntpath
def get_motif_files(motifs):
    out = {}
    for name in motifs.keys():
        out[name] = {}
        files = glob.glob('{name}/*'.format(name = motifs[name]))
        for f in files:
            fname = ntpath.basename(f)
            out[name][fname] = f
    return out


motif_dic = get_motif_files(config['motifs'])

rule scan_motif_score_in_region:
    input:
        fasta = 'data/scan/{sample}.extend_{size}.fasta.gz'
    params:
        threshold = lambda wildcards: config['active_motifs']['score_threshold']
    output:
        'data/scan/{motif_dir}/{motif_name}__{sample}.extend_{size}.active_region.bed.gz'
    shell:
        '''
        python scripts/scan_motif_in_region.py \
        --fasta {input.fasta} \
        --motif_name {wildcards.motif_name} \
        --output {output[0]} \
        --threshold {params.threshold} \
        --motif_dir {wildcards.motif_dir}
        '''

rule scan_summarize:
    input:
        lambda wildcards: get_all_region_scanning(config, wildcards.motif_dir)
    output:
        'data/active_motifs/{motif_dir}__{sample}.extend_{size}.active_motif_list.txt'
    shell:
        '''
        wc -l {input[0]} | sort -nr -k1 | sed 's/  //gc' > {output[0]}
        '''

rule train_centipede:
    input:
        active_region = 'data/scan/{motif_dir}/{motif_name}__{sample}.extend_{size}.active_region.bed.gz',
        mpile = 'data/pile/{sample}.mpile.gz'
    params:
        centipede = config['centipede']
    output:
        'model/{motif_dir}/{motif_name}__{sample}.extend_{size}.rds'
    shell:
        'Rscript train_centipede.R \
        --active_region {input.motif_score} \
        --mpile {input.mpile} \
        --centipede_path {params.centipede} \
        --output {output[0]}'

rule predict_centipede:

rule variant_in_bed:
